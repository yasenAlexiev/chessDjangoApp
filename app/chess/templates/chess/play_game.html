{% extends 'chess/base.html' %}
{% load static %}

{% block title %}Game {{ game.id }}{% endblock %}

{% block content %}

    <div class="container mt-4">
        <h2>Game #{{ game.id }}</h2>
        <div class="row">
            <div class="col-md-8">
                <div class="chess-board" id="chessBoard"></div>
            </div>
            <div class="col-md-4">
                <h4>Game History</h4>
                <ul id="gameHistory" class="list-group">
                    <!-- Moves will be dynamically added here -->
                </ul>
            </div>
        </div>
    </div>

    <style>
        .chess-board {
            width: 644px; /* Adjust board size here */
            height: 644px; /* Adjust board size here */
            display: grid;
            grid-template-columns: repeat(8, 80px); /* Adjust square size here */
            grid-template-rows: repeat(8, 80px);   /* Adjust square size here */
            gap: 0;
        }

        .chess-square {
            width: 80px; /* Adjust square size here */
            height: 80px; /* Adjust square size here */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            z-index: 1; /* Ensure squares are above other elements */
        }

        .chess-square.white {
            background-color: #f0d9b5; /* Light square color */
        }

        .chess-square.black {
            background-color: #b58863; /* Dark square color */
        }

        .chess-square img {
            width: 80%; /* Adjust piece size relative to square */
            height: 80%; /* Adjust piece size relative to square */
            z-index: 10; /* Ensure pieces are above squares */
            pointer-events: auto;
        }

        .chess-square.valid-move {
            background-color: rgba(0, 255, 0, 0.5); /* Highlight valid moves */
        }

        .list-group {
            max-height: 644px;
            overflow-y: auto;
        }

        .list-group-item {
            font-size: 14px;
        }

        .list-group-item.bg-white {
            background-color: #ffffff; /* White background */
        }

        .list-group-item.bg-light {
            background-color:rgba(65, 72, 79, 0.5); /* Light gray background */
        }
    </style>

    <script>
      
        const board = document.getElementById('chessBoard');
        let currentTurn = 'white'; // Track whose turn it is
        let moveHistory = []; // Array to store the history of moves

        // Piece image URLs (using Wikipedia SVGs)
        const pieces = {
            white: {
                king: 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg',
                queen: 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg',
                rook: 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
                bishop: 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
                knight: 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',
                pawn: 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg'
            },
            black: {
                king: 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg',
                queen: 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg',
                rook: 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
                bishop: 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
                knight: 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',
                pawn: 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg'
            }
        };

        // Create square
        function createSquare(row, col) {
            const square = document.createElement('div');
            // Assign alternating colors based on row and column indices
            square.className = `chess-square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
            square.dataset.row = row;
            square.dataset.col = col;

            square.addEventListener('dragover', e => e.preventDefault());

            return square;
        }

        // Create piece
        function createPiece(id, src, color, type, row, col) {
            const img = document.createElement('img');
            img.src = src;
            img.id = id;
            img.draggable = true;
            img.dataset.color = color;
            img.dataset.type = type;
            img.dataset.row = row;
            img.dataset.col = col;
    
            img.addEventListener('dragstart', e => {
                const pieceColor = e.target.dataset.color;
                if (pieceColor !== currentTurn) {
                    e.preventDefault();
                    return;
                }
    
                const fromRow = parseInt(e.target.dataset.row);
                const fromCol = parseInt(e.target.dataset.col);
                const validMoves = getValidMoves(fromRow, fromCol, pieceColor, e.target.dataset.type);
                highlightSquares(validMoves);
                e.dataTransfer.setData('text/plain', e.target.id);
            });
    
            img.addEventListener('dragend', e => {
                console.log("dragend triggered");

                // Get the square where the piece was dropped
                let dropTarget = document.elementFromPoint(e.clientX, e.clientY);
                // Traverse up the DOM tree to find the parent square
                while (dropTarget && !dropTarget.classList.contains('chess-square')) {
                    dropTarget = dropTarget.parentElement;
                }

                if (dropTarget && dropTarget.classList.contains('chess-square')) {
                    const toRow = parseInt(dropTarget.dataset.row);
                    const toCol = parseInt(dropTarget.dataset.col);
            
                    // Move the piece to the new square
                    const fromRow = parseInt(e.target.dataset.row);
                    const fromCol = parseInt(e.target.dataset.col);
            
                    if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                        // Update boardState
                        const piece = boardState[fromRow][fromCol];
                        const targetPiece = boardState[toRow][toCol]; // Check if there's a piece at the target square
            
                        // Record the move in chess notation
                        let move;
                        if (targetPiece) {
                            // Capture move
                            move = `${piece.type === 'pawn' ? '' : piece.type[0].toUpperCase()}x${getChessNotationSquare(toRow, toCol)}`;
                        } else {
                            // Regular move
                            move = `${piece.type === 'pawn' ? '' : piece.type[0].toUpperCase()}${getChessNotationSquare(toRow, toCol)}`;
                        }
            
                        boardState[toRow][toCol] = piece; // Move the piece
                        boardState[fromRow][fromCol] = null; // Clear the original square
                        console.log("toRow", toRow, "toCol", toCol, "piece", piece);
                        moveHistory.push(move);
                        updateGameHistory();
            
                        // Switch turn
                        currentTurn = currentTurn === 'white' ? 'black' : 'white';
            
                        // Redraw the board
                        renderBoard();
                    }
                }
            
                // Clear highlights
                clearHighlights();
            });
    
            return img;
        }

      
        function highlightSquares(moves) {
            moves.forEach(({ toRow, toCol }) => {
                const square = getSquare(toRow, toCol);
                square.classList.add('valid-move');
            });
        }
    
        function clearHighlights() {
            document.querySelectorAll('.valid-move').forEach(sq => {
                sq.classList.remove('valid-move');
            });
        }
    
        function getSquare(row, col) {
            return board.children[row * 8 + col];
        }
    
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            const validMoves = getValidMoves(parseInt(fromRow), parseInt(fromCol), currentTurn, boardState[fromRow][fromCol].type);
            return validMoves.some(m => m.toRow == toRow && m.toCol == toCol);
        }

        const boardState = Array(8)
        .fill(null)
        .map(() => Array(8).fill(null));

        // Setup initial chessboard
        const initialSetup = {
            0: ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'],
            1: Array(8).fill('pawn'),
            6: Array(8).fill('pawn'),
            7: ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook']
        };

        function initializeBoard() {
            // Populate boardState with the initial setup
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (initialSetup[row]) {
                        const pieceType = initialSetup[row][col];
                        const color = row < 2 ? 'black' : 'white';
                        boardState[row][col] = { type: pieceType, color: color };
                    } else {
                        boardState[row][col] = null;
                    }
                }
            }

            renderBoard(); // Draw the board
        }

        function getValidMoves(fromRow, fromCol, color, type) {
            const moves = [];
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
        
            const isInBounds = (r, c) => r >= 0 && r < 8 && c >= 0 && c < 8;
            
            const getPieceAt = (r, c) => {
                if (!isInBounds(r, c)) return null;
                return boardState[r][c];
            };
        
            const addMove = (r, c) => {
                if (!isInBounds(r, c)) return;
                const target = getPieceAt(r, c);
                if (!target || target.color !== color) {
                    moves.push({ toRow: r, toCol: c });
                }
            };
            
            if (type === 'pawn') {
                const oneStep = fromRow + direction;
                const twoStep = fromRow + 2 * direction;
        
                if (isInBounds(oneStep, fromCol) && !getPieceAt(oneStep, fromCol)) {
                    moves.push({ toRow: oneStep, toCol: fromCol });
        
                    if (fromRow === startRow && !getPieceAt(twoStep, fromCol)) {
                        moves.push({ toRow: twoStep, toCol: fromCol });
                    }
                }
        
                [-1, 1].forEach(deltaCol => {
                    const r = fromRow + direction;
                    const c = fromCol + deltaCol;
                    const target = getPieceAt(r, c);
                    if (target && target.color !== color) {
                        moves.push({ toRow: r, toCol: c });
                    }
                });
        
            } else if (type === 'rook' || type === 'bishop' || type === 'queen') {
                const directions = [];
        
                if (type === 'rook' || type === 'queen') {
                    directions.push([1, 0], [-1, 0], [0, 1], [0, -1]);
                }
        
                if (type === 'bishop' || type === 'queen') {
                    directions.push([1, 1], [1, -1], [-1, 1], [-1, -1]);
                }
        
                for (let [dr, dc] of directions) {
                    let r = fromRow + dr;
                    let c = fromCol + dc;
                    while (isInBounds(r, c)) {
                        const target = getPieceAt(r, c);
                        if (!target) {
                            moves.push({ toRow: r, toCol: c });
                        } else {
                            if (target.color !== color) {
                                moves.push({ toRow: r, toCol: c });
                            }
                            break;
                        }
                        r += dr;
                        c += dc;
                    }
                }
        
            } else if (type === 'knight') {
                const deltas = [
                    [2, 1], [2, -1], [-2, 1], [-2, -1],
                    [1, 2], [1, -2], [-1, 2], [-1, -2],
                ];
                deltas.forEach(([dr, dc]) => {
                    const r = fromRow + dr;
                    const c = fromCol + dc;
                    addMove(r, c);
                });
        
            } else if (type === 'king') {
                const deltas = [
                    [1, 0], [-1, 0], [0, 1], [0, -1],
                    [1, 1], [1, -1], [-1, 1], [-1, -1],
                ];
                deltas.forEach(([dr, dc]) => {
                    const r = fromRow + dr;
                    const c = fromCol + dc;
                    addMove(r, c);
                });
            }
        
            return moves;
        }

        function renderBoard() {
            board.innerHTML = ''; // Clear the board
        
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = createSquare(row, col);
                    board.appendChild(square);
        
                    const piece = boardState[row][col];
                    if (piece) {
                        const img = createPiece(
                            `${piece.type}-${piece.color}-${row}-${col}`,
                            pieces[piece.color][piece.type],
                            piece.color,
                            piece.type,
                            row,
                            col
                        );
                        square.appendChild(img);
                    }
                }
            }
        }
        
        function updateGameHistory() {
            const gameHistoryElement = document.getElementById('gameHistory');
            gameHistoryElement.innerHTML = ''; // Clear the current history
        
            moveHistory.forEach((move, index) => {
                const listItem = document.createElement('li');
                listItem.className = `list-group-item ${index % 2 === 0 ? 'bg-white' : 'bg-light'}`; // Alternate row colors
                listItem.textContent = `${index + 1}. ${move}`;
                gameHistoryElement.appendChild(listItem);
            });
        }

        function getChessNotation(type, fromRow, fromCol, toRow, toCol) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const ranks = [8, 7, 6, 5, 4, 3, 2, 1];
        
            const pieceNotation = type === 'pawn' ? '' : type[0].toUpperCase(); // Use uppercase for pieces, no notation for pawns
            const fromSquare = `${files[fromCol]}${ranks[fromRow]}`;
            const toSquare = `${files[toCol]}${ranks[toRow]}`;
        
            return `${pieceNotation}${toSquare}`; // Example: Nf6, e4
        }

        function getChessNotationSquare(row, col) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const ranks = [8, 7, 6, 5, 4, 3, 2, 1];
            return `${files[col]}${ranks[row]}`;
        }

        document.addEventListener('DOMContentLoaded', initializeBoard);
    </script>
{% endblock %}